#version 460
#define localSizeX  8
#define localSizeY  8
#define localSizeZ  1
#define EPSILON 1e-4
#define FLT_MAX 3.40282347e+38
#define FLT_MIN -3.40282347e+38
#define MAX_DEPTH 1000000
#define PI 3.14159265
#define TWO_PI 6.28318530718
#define ONE_OVER_PI (1.0 / PI)
#define ONE_OVER_2PI (1.0 / TWO_PI)
#define saturate(value) clamp(value, 0.0, 1.0)

layout(local_size_x = localSizeX, local_size_y = localSizeY) in;

struct Ray
{
    vec3 origin;
    vec3 direction;
};
layout (constant_id = 0) const bool _Compression = true;
struct SourceBox
{
    ivec4 BBoxA; //min xyz , max x
    ivec4 BBoxB; //max yz , bufferoffsetHi, bufferoffsetLo
};

layout(std140, set = 0, binding = 0) uniform CamBuf
{
    mat4 _CameraToWorld;
    mat4 _CameraInverseProjection;
} _CameraProperites;

layout(std140, set = 1, binding = 0) uniform VoxGridInfo
{
    float MinValue;
    float MaxValue;
    uint Size;
    uint Depth;
    uvec3 Dimensions;
} _VoxelGridInfo;

layout(std430, set = 1, binding = 1) buffer VoxDataBuf
{
    uint[] Nodes;
} _VoxelData;

layout(std430, set = 1, binding = 2) buffer VoxValueBuf
{
    float[] Values;
} _VoxelValues;


layout(set = 2, rgba8, binding = 0) uniform image2D screen;

// --- MATLAB Jet Colour Scheme ---
vec3 SpectralJet(float x)
{
    vec3 c;
    if (x < 0.25)
        c = vec3(0.0, 4.0 * x, 1.0);
    else if (x < 0.5)
        c = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));
    else if (x < 0.75)
        c = vec3(4.0 * (x - 0.5), 1.0, 0.0);
    else
        c = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);

    // Clamp colour components in [0,1]
    return saturate(c);
}

Ray CreateRay(vec3 origin, vec3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
//    ray.tmax = MAX_DEPTH;
//    ray.tmin = 0.0;
    return ray;
}

Ray CreateCameraRay(vec2 rayCoords)
{
    // Transform the camera origin to world space
    const vec3 origin = (_CameraProperites._CameraToWorld * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

    // Invert the perspective projection of the view-space position
    vec3 direction = (_CameraProperites._CameraInverseProjection * vec4(rayCoords, 0.0, 1.0)).xyz;

    // Transform the direction from camera to world space and normalize
    direction = normalize((_CameraProperites._CameraToWorld * vec4(direction, 0.0)).xyz);
    return CreateRay(origin, direction);
}

// https://gist.github.com/franjaviersans/885c136932ef37d8905a6433d0828be6
uint PadTwoZeros(in uint n)
{
    //Mask to 0-1023
    n &= 0x000003ff;

    n = (n ^ (n << 16)) & 0xff0000ff;
    n = (n ^ (n << 8)) & 0x0300f00f;
    n = (n ^ (n << 4)) & 0x030c30c3;
    n = (n ^ (n << 2)) & 0x09249249;
    return n;
}

uvec3 PadTwoZerosEx(in uvec3 n)
{
    //Mask to 0-1023
    n &= 0x000003ff;

    n = (n ^ (n << 16)) & 0xff0000ff;
    n = (n ^ (n << 8)) & 0x0300f00f;
    n = (n ^ (n << 4)) & 0x030c30c3;
    n = (n ^ (n << 2)) & 0x09249249;
    return n;
}

uint Interleave3(in uvec3 pos)
{
     uvec3 val = PadTwoZerosEx(pos);
    return val.z | (val.y << 1) | (val.x << 2);
    //return PadTwoZeros(pos.z) | (PadTwoZeros(pos.y) << 1) | (PadTwoZeros(pos.x) << 2);
}

uint LayerSize(uint layer)
{
    return 1 << (layer * 3); //-> 1, 8, 64, 512, 4096
}

uint GetOctalDigit(uint treeIndex, uint layer)
{
    return (treeIndex >> (layer * 3)) & 7; // range 0-8 octant select
}

bool IntersectBox(vec3 rayOrigin, vec3 invDir, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) 
{
    vec3 tNearCandidate = (boxMin - rayOrigin) * invDir;
    vec3 tFarCandidate = (boxMax - rayOrigin) * invDir;

    vec3 tMin = min(tNearCandidate, tFarCandidate);
    vec3 tMax = max(tNearCandidate, tFarCandidate);

    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);

    return tNear <= tFar && tFar > 0.0;
}
// Adapted From: https://iquilezles.org/articles/boxfunctions/
bool boxIntersection(in vec3 rayOrigin, in vec3 invDir, in vec3 size, out float tNear, out float tFar) 
{
    vec3 projectedRay = invDir * rayOrigin;
    vec3 tExtents = abs(invDir) * size;
    vec3 tMin = (-projectedRay) - tExtents;
    vec3 tMax = (-projectedRay) + tExtents;
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    return tNear <= tFar && tFar > 0.0;
}

void main()
{
    ivec2 resolution = imageSize(screen);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    // PixelPos is out of range of texture
    if(any(greaterThanEqual(pixelPos, resolution)))
    {
        return;
    }
    
    // Transform pixel to [-1,1] range
    vec2 uv = vec2((pixelPos + vec2(0.5, 0.5)) / vec2(resolution.x, resolution.y));
    vec2 rayCoords = uv * 2.0 - 1.0;
    
    Ray ray = CreateCameraRay(rayCoords);
    
    float maxValue = 0;
    const vec3 invDir = 1.0 / ray.direction;

    // Get the sourceData box
    const uvec3 boxSize = uvec3(_VoxelGridInfo.Size);
    const vec3 bSize = vec3(boxSize);
    //Steps needed to reach the end of the volume cube (x+y+z iterations)
    uint steps = uint(ceil(dot(vec3(1), bSize)));
    
    // Warp ray to begining of volume box
    if (!(all(lessThanEqual(ray.origin, bSize)) && all(greaterThan(ray.origin, vec3(0)))))
    {    
        float firstHit;
        float dummy;
        if (IntersectBox(ray.origin, invDir, vec3(0), bSize, firstHit, dummy))
        {
            firstHit += 0.01;
            ray.origin = ray.origin + ray.direction * firstHit;
        }
    }

    uvec3 gridPos = uvec3(ray.origin);
    const vec3 deltaDist = max(abs(invDir), 0.001);         // Percentage to step in per axis
    const vec3 rayStepF = sign(ray.direction);              // Positive or Negative step
    const vec3 blockOffset = (vec3(gridPos) - ray.origin);  // Difference between quantized position and actual position
    const vec3 posDiff = rayStepF * blockOffset;            // Absolute Difference between quantized position and actual position
    const vec3 absoluteStep = (rayStepF * 0.5) + 0.5;       // Bring step from -1 .. 1  to 0 .. 1
    vec3 sideDist = (posDiff + absoluteStep) * deltaDist;   // Total absolute difference in positon from start
    
    const float dataRange = _VoxelGridInfo.MaxValue - _VoxelGridInfo.MinValue;
    const uint maxDepth = _VoxelGridInfo.Depth;
    const uint highestLevel = maxDepth - 1;
    while(steps > 0 && all(lessThan(gridPos, boxSize))) // Step thru octree
    {                 
        steps--;
//        uint stack[10];
        uint treeIndex = Interleave3(gridPos); 
        uint childrenStart = 0; //root
        uint node = _VoxelData.Nodes[childrenStart]; 
        for (uint i = highestLevel; true; i--)
        {            
            uint selectedChild = GetOctalDigit(treeIndex, i); 
            uint childBit = 1 << selectedChild; 
            uint childBits = node >> 24;             
            uint childIndex = bitCount(childBits & (childBit - 1));
            bool hasChild = ((childBits & childBit) != 0);
            bool isFull = childBits == 0;
            bool willStep = (i == 0) || !hasChild || isFull;

            childrenStart += (node & 0x00ffffff);
//            stack[i] = childrenStart | (node & 0xff000000);
            if(willStep)
            {
                if(i == 0 || isFull)
                {                
                    if(hasChild || isFull)
                    {
                        float voxelValue;
                        childrenStart = (node & 0x00ffffff);
                        if(!_Compression || (bitCount(childBits) <= 3 && !isFull))
                        {
                            voxelValue = _VoxelValues.Values[childrenStart + childIndex]; 
                            maxValue = max(voxelValue, maxValue); 
                        }
                        else
                        {
                            uint index;
                            if(isFull)
                            {
                                index = treeIndex & ((1 << ((i + 1) * 3)) - 1);
                            }
                            else
                            {
                                index = childIndex;
                            }
                            vec2 minMax = unpackUnorm2x16(floatBitsToUint(_VoxelValues.Values[childrenStart++]));
                                                                            
                            float blockMin = fma(minMax.x, dataRange, _VoxelGridInfo.MinValue);
                            float blockMax = fma(minMax.y, dataRange, _VoxelGridInfo.MinValue);
                        
                            uint child = index >> 2;
                            uint shift = index & 0x3;
                            uint encodedBits = floatBitsToUint(_VoxelValues.Values[childrenStart + child]);
                            float scaledDifference = unpackUnorm4x8(encodedBits)[shift];

                            voxelValue = mix(blockMin, blockMax, scaledDifference);                     
                            maxValue = max(voxelValue, maxValue); 
                        }
                    }

                    const vec3 mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));  //Smallest axis to step in       
                    sideDist += mask * deltaDist;                                           //Step along smallest direction & accumulate distance travelled
                    gridPos += ivec3(mask * rayStepF);                                      //Step along smallest direction & accumulate integer distance                   
                }
//                else if(isFull && _Compression)
//                {
//                    const uvec3 octants = uvec3(gridPos >> i);
//                    const uint size = 1 << i;
//                    const uvec3 minBox = uvec3(octants << i);
//                    const uvec3 maxBox = uvec3((uvec3(1) + octants) << i);
//
//                    childrenStart = (node & 0x00ffffff);
//
//                    vec2 minMax = unpackUnorm2x16(floatBitsToUint(_VoxelValues.Values[childrenStart]));
//                    float blockMin = fma(minMax.x, dataRange, _VoxelGridInfo.MinValue);
//                    float blockMax = fma(minMax.y, dataRange, _VoxelGridInfo.MinValue);
//
//                    float range = blockMax - blockMin;
//
//                    do
//                    {
//        //                uint index = (((gridPos.z << i) + gridPos.y) << i) + gridPos.x;
//                        const uint index = treeIndex & ((1 << ((i + 1) * 3)) - 1);
//                        const uint child = index >> 2;
//                        const uint shift = index & 0x3;
//                        const uint encodedBits = floatBitsToUint(_VoxelValues.Values[childrenStart + child + 1]);
//                        const float scaledDifference = unpackUnorm4x8(encodedBits)[shift];
//                        const float voxelValue = fma(scaledDifference, range, blockMin); 
//                        maxValue = max(voxelValue, maxValue); 
//
//                        const vec3 mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));  //Smallest axis to step in       
//                        sideDist += mask * deltaDist;                                           //Step along smallest direction & accumulate distance travelled
//                        gridPos += ivec3(mask * rayStepF);                                      //Step along smallest direction & accumulate integer distance    
//                        treeIndex = Interleave3(gridPos);
//                    } while(all(lessThan(gridPos, maxBox)) && all(greaterThanEqual(gridPos, minBox)));
//                } 
                else if(!hasChild)
                {  
                    const uvec3 octants = uvec3(gridPos >> i);
                    const vec3 minBox = vec3(octants << i);
                    const vec3 maxBox = vec3((uvec3(1) + octants) << i);

                    float near;
                    float far;
                    bool hit = IntersectBox(ray.origin, invDir, minBox, maxBox, near, far);
                    float maxHit = max(far+0.1,0.1);
                    ray.origin = ray.origin + ray.direction * maxHit;
                    //Needed to avoid infinite steps due to float -> int conversion in glsl
                    if(any(lessThan(ray.origin, vec3(0))))
                    {
                        steps = 0; 
                        break;
                    }
                    gridPos = uvec3(ray.origin);
                    const vec3 nextBlockOffset = (vec3(gridPos) - ray.origin);          //Difference between quantized position and actual position
                    const vec3 nextPosDiff = rayStepF * nextBlockOffset;                //Difference between quantized position and actual position
                    sideDist = (nextPosDiff + absoluteStep) * deltaDist;                //Total absolute difference in positon from start
                } 
                break;
//                uint prevIndex = treeIndex;
//                treeIndex = Interleave3(gridPos);
//                uint changes = prevIndex ^ treeIndex;
//                uint startingLevel = (findMSB(changes) / 3) + 1; //last shared node
//                if(startingLevel >= highestLevel || i >= startingLevel)
//                {
//                    break;
//                }
//                i = startingLevel;
//                selectedChild = GetOctalDigit(treeIndex, i);    
//                uint parentNode = stack[i];
//                childrenStart = parentNode & 0x00FFFFFF;
//                childBits = parentNode >> 24;             
//                childBit = 1 << selectedChild; 
//                childIndex = bitCount(childBits & (childBit - 1));    
            }
            node = _VoxelData.Nodes[childrenStart + childIndex];            
        }

    }
    
    const vec3 mainColor = SpectralJet(maxValue / _VoxelGridInfo.MaxValue);
    const vec3 contentColor = mix(vec3(0), mainColor, maxValue / _VoxelGridInfo.MaxValue); 
    imageStore(screen, pixelPos, vec4(contentColor, 1.0));
}