#version 460
#define localSizeX  8
#define localSizeY  8
#define localSizeZ  1

#define EPSILON 1e-4
#define FLT_MAX 3.40282347e+38
#define FLT_MIN -3.40282347e+38
#define MAX_DEPTH 1000000
#define PI 3.14159265
#define TWO_PI 6.28318530718
#define ONE_OVER_PI (1.0 / PI)
#define ONE_OVER_2PI (1.0 / TWO_PI)
#define saturate(value) clamp(value, 0.0, 1.0)

layout(local_size_x = localSizeX, local_size_y = localSizeY) in;

struct Ray
{
    vec3 origin;
    vec3 direction;
    float tmin;
    float tmax;
};

struct SourceBox
{
    ivec4 BBoxA; //min xyz , max x
    ivec4 BBoxB; //max yz , bufferoffsetHi, bufferoffsetLo
};

layout(std140, set = 0, binding = 0) uniform CamBuf
{
    mat4 _CameraToWorld;
    mat4 _CameraInverseProjection;
} _CameraProperites;

layout(std430, set = 1, binding = 0) buffer VoxDataBuf
{
    float[] Values;
} _VoxelData;

layout(std140, set = 1, binding = 1) uniform VoxGridInfo
{
    float MinValue;
    float MaxValue;
    int pad0;
    int pad1;
    ivec3 GridDims;
} _VoxelGridInfo;

layout(std430, set = 1, binding = 2) buffer VoxSourceBuf
{
    SourceBox[] SourceBoxes;
} _VoxelSourceData;

layout(set = 2, rgba8, binding = 0) uniform image2D screen;

// --- MATLAB Jet Colour Scheme ---
vec3 spectral_jet(float x)
{
    vec3 c;
    if (x < 0.25)
        c = vec3(0.0, 4.0 * x, 1.0);
    else if (x < 0.5)
        c = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));
    else if (x < 0.75)
        c = vec3(4.0 * (x - 0.5), 1.0, 0.0);
    else
        c = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);

    // Clamp colour components in [0,1]
    return saturate(c);
}

Ray CreateRay(vec3 origin, vec3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.tmax = MAX_DEPTH;
    ray.tmin = 0.0;
    return ray;
}

Ray CreateCameraRay(vec2 rayCoords)
{
    // Transform the camera origin to world space
    const vec3 origin = (_CameraProperites._CameraToWorld * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

    // Invert the perspective projection of the view-space position
    vec3 direction = (_CameraProperites._CameraInverseProjection * vec4(rayCoords, 0.0, 1.0)).xyz;

    // Transform the direction from camera to world space and normalize
    direction = normalize((_CameraProperites._CameraToWorld * vec4(direction, 0.0)).xyz);
    return CreateRay(origin, direction);
}

int IntersectClosestNode(in Ray ray, in vec3 inv_dir, out float hitMin, out float hitMax)
{
    hitMin = MAX_DEPTH;
    hitMax = MAX_DEPTH;
    int best = -1;
    
    //loop through all nodes
    for(int i = 0; i < _VoxelSourceData.SourceBoxes.length(); i++)
    {
        SourceBox sBox = _VoxelSourceData.SourceBoxes[i];
        vec3 bboxMin = (vec3(sBox.BBoxA.xyz));
        vec3 bboxMax = (vec3(sBox.BBoxA.w, sBox.BBoxB.xy));
        vec3 tmin_temp = (bboxMin - ray.origin) * inv_dir;
        vec3 tmax_temp = (bboxMax - ray.origin) * inv_dir;
        vec3 tmin = min(tmin_temp, tmax_temp);
        vec3 tmax = max(tmin_temp, tmax_temp);
        
        float tempHitMin = max(tmin.x, max(tmin.y, max(tmin.z, ray.tmin)));
        float tempHitMax = min(tmax.x, min(tmax.y, min(tmax.z, ray.tmax)));

        // if the ray goes thrugh this box AND we have not found a closer box, then update index
        if(tempHitMin <= tempHitMax && tempHitMin <= hitMin)
        {
            hitMin = tempHitMin;
            hitMax = tempHitMax;
            best = i;
        }
    }
    return best;
}

void main()
{
    ivec2 resolution = imageSize(screen);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    if(any(greaterThanEqual(pixelPos, resolution)))
    {
        return;
    }
    vec2 uv = vec2((pixelPos + vec2(0.5, 0.5)) / vec2(resolution.x, resolution.y));
    vec2 rayCoords = uv * 2.0 - 1.0;

    Ray ray = CreateCameraRay(rayCoords);

    const vec3 rayStepF = sign(ray.direction);
    const ivec3 rayStep = ivec3(rayStepF);   
    const vec3 deltaDist = abs(vec3(length(ray.direction)) / ray.direction);

    int prevNodeIndex = -1;
    float maxValue = 0;
    const vec3 inv_dir = 1.0 / (ray.direction);
    while(true)
    {
        float hitMin;
        float hitMax;
        int nodeIndex = IntersectClosestNode(ray, inv_dir, hitMin, hitMax);
        if(nodeIndex < 0 || prevNodeIndex == nodeIndex) break;        

        ivec3 gridPos = ivec3(floor(ray.origin + ray.direction * (hitMin + EPSILON)));

        const SourceBox sBox = _VoxelSourceData.SourceBoxes[nodeIndex];
        const ivec3 minPos = sBox.BBoxA.xyz;
        const ivec3 maxPos = ivec3(sBox.BBoxA.w, sBox.BBoxB.xy);
        const uvec3 boxSize = maxPos - minPos;

        const uint itCount = uint(ceil(dot(vec3(1), vec3(boxSize))));
        vec3 sideDist = (rayStepF * (vec3(gridPos) - ray.origin) + (rayStepF * 0.5) + 0.5) * deltaDist; 
        for (int i = 0; i < itCount; i++) 
        {
            float densityValue = 0;
            const uvec3 localGridPos = gridPos - minPos;
            if(any(lessThan(boxSize, localGridPos)))
            {
                break;
            }
            else 
            {    
                densityValue = _VoxelData.Values[uint(sBox.BBoxB.z) + ((localGridPos.z) * boxSize.y + localGridPos.y) * boxSize.x + localGridPos.x];

                vec3 mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
                sideDist += mask * deltaDist;            
                gridPos += ivec3(mask) * rayStep;
            
                maxValue = max(maxValue, densityValue);
            }

        }
        ray.tmin = hitMax + EPSILON;
        prevNodeIndex = nodeIndex;
    } 
       
    const vec3 mainColor = spectral_jet(maxValue / _VoxelGridInfo.MaxValue);
    const vec3 contentColor = mix(vec3(0), mainColor, maxValue / _VoxelGridInfo.MaxValue);

    imageStore(screen, pixelPos, vec4(contentColor, 1.0));
}