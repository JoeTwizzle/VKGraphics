#version 460
#define localSizeX  8
#define localSizeY  8
#define localSizeZ  1

#define EPSILON 1e-4
#define FLT_MAX 3.40282347e+38
#define FLT_MIN -3.40282347e+38
#define MAX_DEPTH 1000000
#define PI 3.14159265
#define TWO_PI 6.28318530718
#define ONE_OVER_PI (1.0 / PI)
#define ONE_OVER_2PI (1.0 / TWO_PI)
#define saturate(value) clamp(value, 0.0, 1.0)

layout(local_size_x = localSizeX, local_size_y = localSizeY) in;

struct Ray
{
    vec3 origin;
    vec3 direction;
    float tmin;
    float tmax;
};

struct SourceBox
{
    ivec4 BBoxA; //min xyz , max x
    ivec4 BBoxB; //max yz , bufferoffset, padding
};

struct BVHNode
{
    vec4 bboxA;
    vec4 bboxB;
};

layout(std140, set = 0, binding = 0) uniform CamBuf
{
    mat4 _CameraToWorld;
    mat4 _CameraInverseProjection;
} _CameraProperites;

layout(std430, set = 1, binding = 0) buffer VoxDataBuf
{
    float[] Values;
} _VoxelData;

layout(std140, set = 1, binding = 1) uniform VoxGridInfo
{
    float MinValue;
    float MaxValue;
    int pad0;
    int pad1;
    ivec3 GridDims;
} _VoxelGridInfo;

layout(std430, set = 1, binding = 2) buffer VoxSourceBuf
{
    SourceBox[] SourceData;
} _VoxelSourceData;

layout (set = 1, std430, binding = 3) buffer BVHNodeBuf
{
    BVHNode[] BVHNodes;
}BvhNodeBuffer;

layout (set = 1, std430, binding = 4) buffer BVHIndexBuf
{
    int[] BVHIndices;
}BvhIndexBuffer;

layout(set = 2, rgba16f, binding = 0) uniform image2D screen;
layout(set = 2, r32f, binding = 1) uniform image2D depth;


// --- MATLAB Jet Colour Scheme ---
vec3 spectral_jet(float x)
{
	vec3 c;
	if (x < 0.25)
		c = vec3(0.0, 4.0 * x, 1.0);
	else if (x < 0.5)
		c = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));
	else if (x < 0.75)
		c = vec3(4.0 * (x - 0.5), 1.0, 0.0);
	else
		c = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);

	// Clamp colour components in [0,1]
	return saturate(c);
}

Ray CreateRay(vec3 origin, vec3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.tmax = MAX_DEPTH;
    ray.tmin = 0.0;
    return ray;
}

Ray CreateCameraRay(vec2 rayCoords)
{
    // Transform the camera origin to world space
    const vec3 origin = (_CameraProperites._CameraToWorld * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

    // Invert the perspective projection of the view-space position
    vec3 direction = (_CameraProperites._CameraInverseProjection * vec4(rayCoords, 0.0, 1.0)).xyz;

    // Transform the direction from camera to world space and normalize
    direction = normalize((_CameraProperites._CameraToWorld * vec4(direction, 0.0)).xyz);
    return CreateRay(origin, direction);
}

int IntersectClosestNode(in Ray ray, out float hitMin, out float hitMax)
{
    hitMin = ray.tmax;
    hitMax = ray.tmax;
    int best = -1;
    vec3 inv_dir = 1.0 / (ray.direction);
    //loop through all nodes
    for(int i = 0; i < _VoxelSourceData.SourceData.length(); i++)
    {
        SourceBox sBox = _VoxelSourceData.SourceData[i];
        vec3 bboxMin = (vec3(sBox.BBoxA.xyz));
        vec3 bboxMax = (vec3(sBox.BBoxA.w, sBox.BBoxB.xy));
        vec3 tmin_temp = (bboxMin - ray.origin) * inv_dir;
        vec3 tmax_temp = (bboxMax - ray.origin) * inv_dir;
        vec3 tmin = min(tmin_temp, tmax_temp);
        vec3 tmax = max(tmin_temp, tmax_temp);
        
        float tempHitMin = max(tmin.x, max(tmin.y, max(tmin.z, ray.tmin)));
        float tempHitMax = min(tmax.x, min(tmax.y, min(tmax.z, ray.tmax)));

        // if the ray goes thrugh this box AND we have not found a closer box, then update index
        if(tempHitMin <= tempHitMax && tempHitMin <= hitMin)
        {
            hitMin = tempHitMin;
            hitMax = tempHitMax;
            best = i;
        }
    }
    return best;
}

bool IntersectNode(in Ray ray, in vec3 bboxMin, in vec3 bboxMax)
{
    vec3 inv_dir = 1.0 / (ray.direction);
    vec3 tmin_temp = (bboxMin - ray.origin) * inv_dir;
    vec3 tmax_temp = (bboxMax - ray.origin) * inv_dir;
    vec3 tmin = min(tmin_temp, tmax_temp);
    vec3 tmax = max(tmin_temp, tmax_temp);
    
    float hitMin = max(tmin.x, max(tmin.y, max(tmin.z, ray.tmin)));
    float hitMax = min(tmax.x, min(tmax.y, min(tmax.z, ray.tmax)));
    return hitMin <= hitMax;
}

shared uint stack[gl_WorkGroupSize.x * gl_WorkGroupSize.y][32];
bool TraverseBVH(inout Ray ray, out SourceBox sBox, out float hitMin, out float hitMax)
{
    uint wgpidx = gl_LocalInvocationID.x*gl_WorkGroupSize.x+gl_LocalInvocationID.y;
    int head = 0;
    stack[wgpidx][head++] = 0;

    while (head > 0)
    {
        BVHNode node = BvhNodeBuffer.BVHNodes[stack[wgpidx][--head]];

        vec3 minAABB = node.bboxA.xyz;
        vec3 maxAABB = vec3(node.bboxA.w, node.bboxB.x, node.bboxB.y);
        if (!IntersectNode(ray, minAABB, maxAABB))
            continue;
           
        uint PrimCount = floatBitsToUint(node.bboxB.z);
        uint FirstIndex = floatBitsToUint(node.bboxB.w);

        if (PrimCount != 0)
        {
            sBox = _VoxelSourceData.SourceData[BvhIndexBuffer.BVHIndices[FirstIndex]];
            vec3 inv_dir = 1.0 / (ray.direction);
            vec3 bboxMin = (vec3(sBox.BBoxA.xyz));
            vec3 bboxMax = (vec3(sBox.BBoxA.w, sBox.BBoxB.xy));
            vec3 tmin_temp = (bboxMin - ray.origin) * inv_dir;
            vec3 tmax_temp = (bboxMax - ray.origin) * inv_dir;
            vec3 tmin = min(tmin_temp, tmax_temp);
            vec3 tmax = max(tmin_temp, tmax_temp);
        
            hitMin = max(tmin.x, max(tmin.y, max(tmin.z, ray.tmin)));
            hitMax = min(tmax.x, min(tmax.y, min(tmax.z, ray.tmax)));
            return true;
        }
        else
        {
            stack[wgpidx][head++] = FirstIndex;
            stack[wgpidx][head++] = FirstIndex + 1;
        }
    }
     return false;
}

// Based of off https://www.shadertoy.com/view/4dX3zl and https://github.com/deibich/source-volume-renderer
void main()
{
    ivec2 resolution = imageSize(screen);
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    // PixelPos is out of range of texture
    if(any(greaterThanEqual(pixelPos, resolution)))
    {
        return;
    }
    // Transform pixel to [-1,1] range
    vec2 uv = vec2((pixelPos + vec2(0.5, 0.5)) / vec2(resolution.x, resolution.y));
    vec2 rayCoords = uv * 2.0 - 1.0;

    Ray ray = CreateCameraRay(rayCoords);

    vec3 color = vec3(0);
    float maxValue = 0;
    //direction to step in 
	const vec3 rayStepF = sign(ray.direction);
	const ivec3 rayStep = ivec3(rayStepF);   
	const vec3 deltaDist = abs(vec3(length(ray.direction)) / ray.direction);
    int prevNodeIndex = -1;
    float transmission = 1;
    vec3 volumeColor = vec3(0);
    int count = _VoxelSourceData.SourceData.length();
    do
    {
        float hitMin;
        float hitMax;
        SourceBox sBox;
        //find the index of the closest node
        bool hitAny = TraverseBVH(ray, sBox, hitMin, hitMax);
        //no more nodes along ray path -> exit and color pixel
        if(!hitAny) break;

        //We intersected the same node twice
        //This can only happen with float precision errors
        //break to avoid timeout
//        if(prevNodeIndex == nodeIndex)
//        {
//            break;
//        }
        ivec3 gridPos = ivec3(floor(ray.origin + ray.direction * (hitMin + EPSILON)));
        
        // Get the sourceData box
//        SourceBox sBox = _VoxelSourceData.SourceData[nodeIndex];
        const ivec3 minPos = sBox.BBoxA.xyz;
        const ivec3 maxPos = ivec3(sBox.BBoxA.w, sBox.BBoxB.xy);
        const ivec3 boxSize = maxPos - minPos;
        //Steps needed to reach the end of the volume cube
        const float itCount = ceil(dot(vec3(1), vec3(boxSize)));
        //Difference between 
        vec3 sideDist = (rayStepF * (vec3(gridPos) - ray.origin) + (rayStepF * 0.5) + 0.5) * deltaDist; 
        
        bvec3 mask;
	    for (int i = 0; i < itCount; i++) 
        {
            float densityValue = 0;
            // check if we are still intersecting the node
            if(!(any(lessThan(gridPos, minPos)) || any(greaterThan(gridPos, maxPos))))
            {
//              hitCount += inc;
                uvec3 localGridPos = gridPos - minPos;
                densityValue = _VoxelData.Values[sBox.BBoxB.z + localGridPos.x + localGridPos.y * boxSize.x  + localGridPos.z * boxSize.x * boxSize.y];
            }
            else //otherwise break
            {    
                break;
            }
            //All components of mask are false except for the corresponding largest component
            //of sideDist, which is the axis along which the ray should be incremented.
            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
            sideDist += vec3(mask) * deltaDist;
            gridPos += ivec3(mask) * rayStep;
            
            transmission *= 1 - (densityValue / _VoxelGridInfo.MaxValue);
            volumeColor += transmission * spectral_jet(densityValue / _VoxelGridInfo.MaxValue);
            maxValue = max(maxValue, densityValue);
	    }
        // set our rays min to past the end of this node so we wont re-intersect it
        ray.tmin = hitMax + (1.0/itCount)+0.5;
//        prevNodeIndex = nodeIndex;
    count--;
    } 
    while(count > 0);
    
    vec3 mainColor = spectral_jet(maxValue / _VoxelGridInfo.MaxValue);
    vec3 bgColor = vec3(0);
    vec3 contentColor = mix(bgColor, mainColor, maxValue / _VoxelGridInfo.MaxValue);
//    vec3 contentColor = volumeColor * (maxValue / _VoxelGridInfo.MaxValue) + bgColor * transmission;
    color = contentColor;
    imageStore(screen, pixelPos, vec4(color, 1.0));
}
